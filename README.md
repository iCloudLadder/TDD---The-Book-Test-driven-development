# TDD---The-Book:Test driven development


# 第一章

TDD 基本步骤：
1. 快速新增一个测试。
2. 运行所有测试，发现最新的测试不能通过。
3. 做一些小小的改动。
4. 运行所有的测试，并且全部通过。
5. 重构（refactor）代码，以消除重复设计，优化设计结构。




(测试程序与代码所存在的问题不在 “重复设计”，而在“依赖关系”)

消除重复设计 就是消除依赖关系

(最终的目标是：编写另一个其他有用的测试代码，而不需要改动代码)

重复设计通常表现在逻辑上的重复设计：相同的表达式在代码的多个地方出现（深刻理解面向对象设计）

要做的事情：
1. 根据需求列一个计划清单（to-do list）。。。。实时更新状态
2. 通过一小段代码说明我们希望看到怎样的一种操作
3. 暂时忽略一下JUnit的细节
4. 通过建立存根来让测试程序通过编译
5. 通过一些另类的做法让测试程序运行通过
6. 逐步使工作代码一般化，用变量代替常量
7. 将新工作列入计划清单，而不是一次全部提出(?????)


# 第二章 变质的对象


TDD总体流程：
1. 写一个测试程序
2. 让测试程序运行
3. 编写合格的代码
最终目标： 可用的，整洁的代码


让程序尽快运行的策略
1. 伪实现
2. 显明实现
3. 三角法


# 第三章 一切均等

数值对象：一旦其实例变量的值在构造函数中被指定，那就不允许在改变

1. 注意到我们的设计模式隐含规定了一种操作
2. 测试这种操作
3. 给他一个简单的实现
4. 暂时不重构，而是进一步测试
5. 重构用例中的重复设计


# 第四章 私有性

1. 使用刚刚开发的新功能来改进一个测试
2. 观察到如果测试都失效了，那么情况就严重了
3. 尽管有个风险，但还是继续前进
4. 使用了测试中对象的新功能以减少测试程序与代码间的耦合度

这是在重构代码


# 第五章 法郎在诉说


1. 无法通过一个大的测试，所以我们先从一个小的测试行动起来
2. 无所顾忌的通过复制和编辑来写出这个测试程序
3. 更糟糕的是，通过将整个模型代码拷贝过来并加以编辑来让测试程序工作
4. 自我保证在重复设计消除之前决不回家

TDD经过的各个阶段：
1. 写一个测试程序
2. 让测试程序编译通过
3. 运行测试程序，发现不能运行
4. 让测试程序可以运行
5. 消除重复设计，优化设计结构




# 第六章 在谈一切均等

1. 逐步将一个类中的公共代码片段移交给父类
2. 将其他有类似的类改为此父类的子类
3. 使两个的equals( )实现一致，然后消除冗余的一个

重构

# 第七章 苹果和橘子

1. 着手解决一个困扰我们的难题并将它转化为一个测试程序
2. 用一个合理并不完美的方法（getClass()）使测试程序通过
3. 除非有更好的动机，否则不要引入更多的设计



# 第八章 制造对象


1. 通过使同一个方法（times()）的两个变种的签名相一致，朝着消除重复设计的方向又前进了一步
2. 至少将这个方法的一个声明移至共同的父类中
3. 通过引用工厂方法，消除测试代码与具体子类存在的耦合
4. 注意到当子类被消除后，一些测试将是冗余的，但我们暂时不管它们



# 第九章 我们所处的时代

1. 大的设计构思受阻，所以着手解决前面发现的小问题
2. 通过将方法变体上移至调用者（工厂方法）是两个构造方法一致
3. 稍微打断一下重构过程，在times()中使用工厂方法
4. 用一大步再做一次同样的重构（对Dollar做我们曾对Franc所做的工作）
5. 把相同的构造函数上移


# 第十章 有趣的Times()方法

不需要写测试程序的代码：
1. 我们是打算在屏幕上查看输出结果
2. 因为toString()仅仅用来输出调试信息，所以它失败带来的风险极低
3. 我们的测试程序还没有通过，在这种情况下我们宁可不写测试程序

1. 为使两个times()操作一致，首先通过内联方式调用需要调用的方法，然后将常量替换为变量
2. 无需实现编写测试程序，直接编写toString()函数以便调试
3. 试着做一下改动（返回Money而不是Franc），让测试告诉我们改动是否可行
4. 恢复实验时做的修改，编写另外一个测试程序。测试程序运行通过了，实验代码就能运行通过


# 第十一章 万恶之源

1. 在掏空子类功能之后将其删除
2. 消除了对旧的代码有意义、而对新的代码结构显得多余的一些测试


# 第十二章 加法，最后的部分


1. 把一个大的测试消减成一个小一些的测试，仍然算是在前进
2. 认真思考可能与我们计算有关的比喻
3. 基于我们新的比喻，重写了前面的测试
4. 让测试尽快通过编译
5. 让测试运行
6. 带着一丝惶恐，期待着为写出真是的实现而必须进行的重构


# 第十三章 完成预期目标

不好的设计：
1. 强制类型转换。这段代码应该对任何代码都使用
2. 公共域以及对它的两级引用


1. 因为重复设计没有完全消除，所以没有把一个测试标记为完成
2. 为了知道能够如何实现，继续往前走而不是往回走
3. 写一个测试，以迫使创建一个我们之后会用到的类（sum）
4. 开始更快的实现（sum的构造函数）
5. 在一个地方使用强制类型转换来实现代码，然后一旦测试通过，就把代码移到它本该属于的地方
6. 为了消除显示的类判断而引入多肽

# 第十四章 变化

用了很短的时间，增加了一个希望会用到的参数

分离代码和测试程序间的数据重复

编写一个测试程序来核实一个我们有关JAVA操作的推断

引入一个私有的帮助类，单并未专门为其提供测试程序

在重构中犯了一个错误，我们选择简陋的解决办法尽快处理通过，并通过编写测试程序来单独考虑这一问题

# 第十五章 混合货币

编写我们想要测试，然后暂且通过简陋的方法让它快速通过运行

先从“叶子”再到“根”（这里指测试用例）来实施一般化（使用更抽象一些的声明）

更具编译器的提示进行修改，这一修改引起一系列的连锁修改

# 第十六章 抽象，最后的工作

编写一个考虑未来读者需求的测试

建议做一个实验，将测试驱动开发与你的现行变成方式相比较

声明变更又一次在系统中触发了一系列连锁修改，与前面一样根据编译器的提示进行修改

尝试一次简短的实验，在它无法工作时放弃掉


# 第十七章 资金实例回顾


下一步做什么？1. 我们需要别的测试吗  2.代码评测，持续改进

比喻

JUnit的用法

代码统计

过程：加入一个小的测试。运行所有测试，运行失败。适当修改。运行测试且成功。重构，消除重复设计，优化设计结构。

测试质量：性能测试。压力测试。可用性测试。语句覆盖量。缺陷插入：改变一行代码的意思，测试应该不能通过。


测试驱动开发中意外的反复出现的三个方面：

让测试利落的运行的三个方法：伪实现，三角法，显明实现

把消除代码和测试间的重复设计作为驱动设计的一种手段

控制测试间隙的能力，当道路光滑时增大摩擦力，在状况解除时放开一些


# 第二部分 xUnit 实例

主要讲一个测试框架


# 第三部分 测试驱动开发

# 第二十五章 测试驱动开发模式

测试是什么意思？

什么时候进行测试？

如何选择测试的逻辑？

如何选择要测试的数据？

测试（名词）

相互独立的测试

测试列表

测试优先

断言优先

测试数据

显然数据

# 第二十六章 不可运行状态模式


什么时候写测试？

在哪里写测试？

什么时候停止写测试？

一步测试、
启动测试、
说明测试、
学习测试、
回归测试、
休息、
重新开始、
便宜的桌子，舒适的椅子


# 第二十七章 测试模式

子测试、
模拟对象、
自分流、
日志字符串、
清扫测试死角、
不完整测试、
提交前保证所有的测试通过


# 第二十八章 可运行模式

伪实现（直到你成功）、
三角法、
显明实现、
从一到多


# 第二十九章 xUnit
测试框架的应用模式：

断言

固定设施 - 在setUp() 里设置通用变量，并初始化-（对对象进行的初始化，对多个测试都是相同的）

外部固定设施 - 在tearDown() 里释放资源 - 测试运行前和运行后状态一致、

测试方法 - 模块、类、方法；

异常测试 - 捕获每个我们期望的异常，如果没有的话才报错、

全部测试 - 一次性执行所有测试， 每个包一个，整个应用是一个集成的测试包



# 第三十章 设计模式

命令：把一个计算作为一个对象而不是消息来调用。

值对象：通过创建其值一经创建便永远不改变的对象来避免别名问题。

空对象：表示一种对象计算的基本形式。

模板方法：使用可以通过继承来具体化的抽象方法来表示计算序列中不变的内容。

插入式对象：通过调用另一个具有两种或两种以上实现的对象来表示变化的内容。

插入式选择器：通过动态调用不同实例的不同方法来避免不必要的子类。

工厂方法：通过调用方法而不是构造函数来创建对象。

冒名顶替：通过引入现有协议的另一种实现来引入变化。

递归组合：使用一个对象来表示一组对象的行为的组合。

收集参数：来回传递一个用来汇集源于不同对象的计算结果的参数。

单例模式：代替全局变量。



# 第三十一章 重构

重构是不能改变程序的语义的。TDD中只对已经通过测试的代码进行重构。

调和差异：两段相似的代码，通过一点一点减小它们的差异，当他们完全一致时才去统一它们。(循环结构，判定语句，方法，类)

隔离变化：在一个具有多个部分的方法或对象进行修改时，对要修改的部分进行隔离。(提取方法，提取对象，方法对象)

数据迁移：在从一种数据表示形式迁移到另一种形式时，可以制作临时冗余数据。

提取方法：将一个既长又复杂的方法中的一小部分，转变成一个独立的方法。

内联方法：在简化过于繁琐和分散的控制流程时，可以在调用的方法的地方把方法内联起来。

提取接口：创建一个包含该共享操作的接口。

转移方法：把方法添加到它所归属的类中。

方法对象：为一个复杂的需要若干参数和局部变量的方法创建对象。

添加参数：

把方法中的参数转变成构造函数中的参数：


# 第三十二章 掌握TDD


步伐应该有多大？
1. 每个测试程序覆盖的方面有多大？
2. 重构是中间步骤有多少？
     一般编写使每个都对应一行逻辑代码和少数重构的测试。


什么可以不必测试？
写测试，一直写到恐惧转变为厌倦到为止。
需要测试的部分：条件部分，循环部分，操作部分，多态性（只测试自己编写的代码？）

怎么知道你的测试有没有漏洞？
1. 过长的设置代码 - 一个断言需要上百行的代码创建队形。
2. 冗余的设置代码 - 无法找到一个存放代码的地方，一定有太多的对象紧密的联系在一起。
3. 过程的测试运行时间 - 不会被经常运行，时间长了容易出问题。
4. 脆弱的测试 - 意外中断的测试，说明某一部分意料地存在对另一部分的影响。

TDD是怎样引领框架形成的？
不为代码的将来考虑，你的代码反而更有可能适应将来的需要。
作者充本书中学到的“编码为今天，设计为明天”， 而TDD则是“为明天编码，为今天设计” ？？？


你需要多少反馈？
TDD对测试的观点是：注重实效，测试是一种达到目的的手段 - 达到充满自信的编写代码的目的。


什么时候应该删除测试？
测试越多越好。
1. 自信 - 如果删除一个测试会降低你对整个系统的信息，那就不能删除。
2. 沟通 - 如果两个测试走了同一条路，但讲述的是不同情形的话，那就应该原封不动的保留。


编程语言和环境怎样影响TDD？

能采用TDD来开发大型系统吗？

能使用应用级的TDD吗？

如何中途转向TDD?







